# プログラミングコンテストの回答

###
# 問題文: 
# 文字列 S が与えられます。 
# S の連続する部分文字列のうち、回文であるものの長さの最大値を求めてください。
# ただし、S の連続する部分文字列であって回文であるものは常に存在します。
#
# 制約: S は長さ 2 以上 100 以下の英大文字からなる文字列
#
# 入力: 入力は以下の形式で標準入力から与えられる。
# S
#
# 出力: S の連続する部分文字列のうち、回文であるものの長さの最大値を出力せよ。
def Longest_Palindrome(S):
    max = 0
    for i in range(len(S)):
        for j in range(i+1, len(S)+1):
            if S[i:j] == S[i:j][::-1] and max < len(S[i:j]):
                max = len(S[i:j])
    return max

# S = input()
# print(Longest_Palindrome(S))

###
# 問題文:
# 3 個のリールからなるスロットがあります。
# i 番目のリールの配列は文字列Si​によって表されます。
# ここで、Si​は数字のみからなる長さM の文字列です。
# それぞれのリールには対応するボタンがついています。
# 高橋君は各非負整数t について、スロットが回り始めてからちょうどt 秒後にボタンを1 つ選んで押す、
# または何もしないことができます。
# スロットが回り始めてからt 秒後にi 番目のリールに対応するボタンを押すと、
# i 番目のリールはSi​の(tmodM)+1 文字目を表示して止まります。
# ただし、tmodM でt をM で割ったあまりを表します。高橋君は全てのリールを止めた上で、表示されている文字が全て同じであるようにしたいです。
# 高橋君が目標を達成できるように全てのリールを止めるまでに、スロットが回り始めてから最小で何秒かかるかを求めてください。
# そのようなことが不可能であればそのことを報告してください。
#
# 制約: 1≤M≤100, Si​は数字のみからなる
#
# 入力: 入力は以下の形式で標準入力から与えられる。
# M
# S1
# S2
# S3
#
# 出力: 高橋君が目標を達成できるように全てのリールを止めるまでに、スロットが回り始めてから最小で何秒かかるかを出力せよ。
# そのようなことが不可能であれば-1を出力せよ。
def Slot(M, S):
    if len(set(S)) == 1:
        return 0
    for i in range(M):
        if len(set([S[0][i], S[1][i], S[2][i]])) == 1:
            return 1
    return -1

# M = int(input())
# S = [input() for i in range(3)]
# print(Slot(M, S))

###
# 問題文:
# 3 個のリールからなるスロットがあります。
# i 番目のリールの配列は文字列Si​によって表されます。
# ここで、Si​は数字のみからなる長さM の文字列です。
# それぞれのリールには対応するボタンがついています。
# 高橋君は各非負整数t について、スロットが回り始めてからちょうどt 秒後にボタンを1 つ選んで押す、
# または何もしないことができます。
# スロットが回り始めてからt 秒後にi 番目のリールに対応するボタンを押すと、
# i 番目のリールはSi​の(tmodM)+1 文字目を表示して止まります。
# ただし、tmodM でt をM で割ったあまりを表します。高橋君は全てのリールを止めた上で、表示されている文字が全て同じであるようにしたいです。
# 高橋君が目標を達成できるように全てのリールを止めるまでに、スロットが回り始めてから最小で何秒かかるかを求めてください。
# そのようなことが不可能であればそのことを報告してください。
#
# 制約: 1≤M≤100, Si​は数字のみからなる
#
# 入力: 入力は以下の形式で標準入力から与えられる。
# M
# S1
# S2
# S3
#
# 出力: 高橋君が目標を達成できるように全てのリールを止めるまでに、スロットが回り始めてから最小で何秒かかるかを出力せよ。
# そのようなことが不可能であれば-1を出力せよ。
# 方針:
# 全ての数字(0~9)について、各リールで何秒後に止めることが出来るかを記録する。また同時にリールを止めることはできないので、リールを止める順番の組み合わせを全て記録する。

def Calc_All_StopTime(S1, S2, S3, value):
    # valueが含まれていないリールが存在する場合はinfを返す
    if value not in S1 or value not in S2 or value not in S3:
        return math.inf
    # 一つ目のリールを止めるまでの時間を計算する
    time = S1.index(value)
    # 二つ目のリールを止めるまでの時間を計算する
    # リールが一周し終わる前に止めることができる場合
    if value in S2[time+1:]:
        time += S2[time+1:].index(value) + 1
    # リールが一周し終わる前に止めることができない場合
    else:
        time = len(S2) + S2.index(value)
    # 三つ目のリールを止めるまでの時間を計算する
    # リールが一周し終わる前に止めることができる場合
    if value in S3[time+1:]:
        time += S3[time+1:].index(value) + 1
    # リールが一周し終わる前に止めることができない場合
    else:
        # 全体として二週目で止めることができる場合
        if time < len(S3):
            time = len(S3) + S3.index(value)
        # 全体として三周目で止めることが出来る場合
        else:
            time = len(S3) * 2 + S3.index(value)
    return time

import math
def Slot2(M, S):
    min_time = math.inf
    for num in range(10):
        # リールを止める順番の組み合わせを全て記録する
        stop_time = []
        for i in range(3):
            for j in range(3):
                for k in range(3):
                    if i != j and j != k and k != i:
                        stop_time.append(Calc_All_StopTime(S[i], S[j], S[k], str(num)))
        # リールを止める順番の組み合わせの中で最小の時間を記録する
        if min_time > min(stop_time):
            min_time = min(stop_time)
    if min_time == math.inf:
        return -1
    else:
        return min_time

M = int(input())
S = [input() for i in range(3)]
print(Slot2(M, S))

        
   